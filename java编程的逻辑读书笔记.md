# 脑图

### java基础

java 基础之**继承**：https://www.processon.com/view/link/6173e2b71e08537415f8672b







### java集合

ArrayList:https://www.processon.com/view/link/61376e1ce401fd1fb6afe32f

LinkedList:https://www.processon.com/view/link/6139c33d1efad40d93a5e396

ArrayDeque:https://www.processon.com/view/link/61dd6b1e1efad4259c5bbfaf

HashMap:https://www.processon.com/view/link/61519138079129511c908cd3

TreeMap:https://www.processon.com/view/link/61dd6b551efad4259c5bc015

HashSet:https://www.processon.com/view/link/61dd6b84f346fb06cb913d91

LinkedHashMap:https://www.processon.com/view/link/61dd6ba01efad4259c5bc09a







### IO流

二进制文件和字节流：https://www.processon.com/view/link/616c10057d9c08665140b91f

java文件概述：https://www.processon.com/view/link/61dd6be80e3e74415778474f







### 并发

并发基础知识：https://www.processon.com/view/link/617ab42f1efad4489404d11b

并发包的基石：https://www.processon.com/view/link/618d1c811efad41bf2c26971







### 堆与优先队列

PriorityQueue:https://www.processon.com/view/link/61dd6cd1e401fd06a8c52580

堆与优先级队列：https://www.processon.com/view/link/6162e1567d9c0866512e589e





# 笔记

## 第一章 编程基础

### 1.1 数据类型和变量

在java中有一下四大种**数据类型**：

1. 整数类型：有4种整型byte/short/int/long,这四种对应的取值范围是不同的
2. 小数类型：有两种类型ﬂoat/double，有不同的取值范围和精度
3. 字符类型：char,表示单个字符
4. 真假类型：boolean，表示真假

**变量**：为了操作数据,需要把数据存放到内存中。所谓内存在程序看来就是一块有**地址编号的连续的空间**,数据放到内存中的某个位置后,为了方便地找到和操作这个数据,需要给这个位置起一个名字，这个名字就是变量。

比如 int a:内存中分配了一块空间,这块空间存放int数据类型, a指向这块内存空间所在的位置,通过对a操作即可操作**a指向的内存空间**,那么a = 5这个操作即可将a指向的内存空间的值改变为5，那么变量的含义就是：**变量就是给数据起名字,方便找不同的数据,它的值可以变,但含义不应变。**



### 1.2.1 赋值与基本类型

**赋值：**声明变量之后,就在内存分配了一块位置，赋值就是把这块位置的内容设为一个**确定的值**。

**基本类型**：

1.整数类型：整数类型有byte、 short、int和long,分别占1、 2、4、 8个字节，他们的取值范围如下

![](https://raw.githubusercontent.com/JOYBOY-777/ReadStudyNote/main/javaimg/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)

不过要注意的是在给long类型赋值的时候,**如果常量超过了int的表示范围**,要在后面加上L

比如：

``` java
long a = 3232343433L;
```



2.小数类型：小数类型有ﬂoat和double,占用的内存空间分别是4和8字节,有不同的取值范围和精度, double表示的范围更大,精度更高。他们的取值范围如下：

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/double.png?raw=true)

在给double赋值的时候就直接赋值就行

```java
double d = 333.33;
```

但是由于小数类型的话默认为double类型那么在赋值float的时候就需要在后面写上f

```java
float f = 333.33f;
```

也可以把小数直接赋值给float,double

```java
float f = 33;
double d = 3333333333333L;
```



3.真假类型：直接赋值就行了

```java
boolean b = true;
b = false;
```



4.字符类型：字符类型用于表示一个字符，可以是**中文字符**，也可以是**英文字符**，char占用两个字节，赋值的时候用''括起来

```java
char c = 'A';
char z = '马 ';
```



### 1.2.2 数组类型

在java中给数据赋值的形式有三种：

```java
1. int[] arr = {1,2,3};
2. int[] arr = new int[]{1,2,3};
3. int[] arr = new int[3];      arr[0]=1; arr[1]=2; arr[2]=3;
```

第三种赋值方式，如果没有给数组赋值那么也会有**默认值**。这个默认值跟数组的类型有关

注意：不能在给定初始值的同时给定长度,这样是不被允许的

```java
int[] arr = new int[3]{1,2,3}
```



数组类型和基本类型是有明显不同的：

1. 一个基本类型变量,内存中只会有一块对应的内存空间
2. 数组有两块内存空间：一块用于存储**数组内容本身**，另一块存储**内容的位置** 

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%88%AB.png?raw=true)

比如数组arr的内存地址是2000，这 个位置存储的值是**一个位置**3000 ，3000开始的位置存储的才是**实际的数据**1 , 2 , 3

为什么这样呢？例子：

```java
int[] arrA = {1,2,3};
int[] arrB = {4,5,6,7};
arrA = arrB;
```

如果arrA对应的内存空间是直接存储的数组内容,那么它将没有足够的空间去容纳arrB的所有元素。

arrA = arrB;其实是体现的如下过程

```java
arrA     {1,2,3}
      \
        \
arrB  -> {4,5,6,7}
```

所以数组变量赋值则会让变量指向一个不同的位置



### 1.3 基本运算

java中的基本类型数据的主要运算包括：

1. 算术运算：主要是日常的加减乘除
2. 比较运算：主要是日常的大小比较
3. 逻辑运算：针对布尔值进行运算



### 1.3.1 算数运算

算数运算包括：加、减、乘、除，符号为：\+ 、 - 、 * 、 /，以及取模运算符（求余）%，以及自增 (++ )和

自减 (-- )运算符

1.加、减、乘、除注意事项

```java
int a = 2147483647*2; //2147483647是int能表示的最大值   a的结果是2
```

运算时要注意结果的范围,**使用恰当的数据类型**,两个正数都可以用int表示,但**相乘的结果可能就会超出**,结果也会让人疑惑，我们应该使用long来接收a，但是但只改为 long也是不够的,因为运算还是**默认按照int类型进行**,需要将**至少一个**数据表示为long形式,即在后面加 L或l

```java
long a = 2147483647*2L;
```

整数想出的时候**不是四舍五入**，而是**直接舍去小数位**

```java
double d = 10/4;
```

如果要想让结果正确的话，也需要将其中之一的数变为小数

```java
a) double d = 10/4.0;
b) double d = 10/(double)4;
```



2.小数的计算结果也不算精确比如：

```java
float f = 0.1f*0.1f;
System.out.println(f); //实际的输出是0.010000001
```



3.自增自减 ++ --

自增/自减是对自己做加1或减1操作,但每个都有两种形式,一种是放在变量后,例如a++、 a-- ,另一 种是放在变量前,例如++a、 --a

这里需要注意：

1. 如果只是对自己操作,这两种形式也没什么差别
2.  当后面还有其他操作时，放在变量后  (a++ )是先**用原来的值**进行其他操作,然后**再对自己做修改**
3. 放在变量前 (++a )是先**对自己做修改**,再用**修改后的值**进行其他操作       可参考下表：

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/%E8%87%AA%E5%A2%9E%E6%93%8D%E4%BD%9C.png?raw=true)



### 1.3.2  比较运算

比较运算就是计算两个值之间的关系,结果是一个**布尔类型** (boolean)的值

比较操作符有大于(>)、大于等于 (>= )、小于(<)、小于等于 (<= )、等于 (== )、不等于 (!= )，一个=表示的是赋值的操作



### 1.3.3 逻辑运算

逻辑运算根据**数据的逻辑关系**,生成一个布尔值true或者false 

逻辑运算符包括：

1. 与 (&):**两个都为true**才是true ,只要有一个是false就是false
2. 或 (|):**只要有一个为true**就是true ,都是false才是false
3. 非(!):针对一个变量, true会变成false , false会变成true
4. 异或 (^):**两个相同为false,两个不相同为true**
5. 短路与 (&&):和&类似
6. 短路或 (||):与|类似

但是&和&&,以及|和||的区别要注意一下：

```java
boolean a = true;
int b = 0;
boolean flag = a | b++>0;
```

|的话就要前后都看，尽管a的值已经是true了，但是也要看一下b，此时b为1，|后面的式子也会进行运算，而||则不同，比如

```java
boolean flag = a || b++>0;
```

则b的值还是0,因为||会“**短路**”,即在看到||前面部分就可以判定结果的情况下,忽略||后面的运算



### 1.4 条件执行

流程控制中最基本的就是条件执行,也就是说,一些操作只能在某些条件满足的情况下才执行,在  一些条件下执行某种操作,在另外一些条件下执行另外的操作。

### 1.4.1 语法和陷阱

if语句：只在条件语句为真的情况下,才执行后面的代码,为假就不执行了。

```java
if(条件语句){
代码块
}
或者
if(条件语句) 代码 ;    
```

具体来说,条件语句必须为布尔值,可以是一个**直接的布尔变量**,也可以是**变量运算后的结果**。建议所有的if后面都加上括号



if else语句：满足的时候执行某种逻辑,而 不满足的时候执行另一种逻辑

```java
if(判断条件){
代码块1
}else{
代码块2
}
```



三元运算符：三元运算符会得到一个结果,判断条件为真的时候就返回表达式1的值,否则就返回表达式2的值

```java
判断条件  ? 表达式  1 :   表达式2
int max = x > y ? x : y;
```



if/else if/else:如果有多个判断条件,而且**需要根据这些判断条件的组合**执行某些操作,容易理解成else if其实不是

```java
if(条件1){
代码块1
}else if(条件2){
代码块2
} …
else if(条件n){
代码块n
}else{
代码块n+1
}
```

条件1满足则执行代码块1,不满足则检查条件2 , …… ,最后如果没有条件满足,且有else语句,则执行else里面的代码最后的else语句不是必需的,**没有就什么都不执行**。



switch case：针对于判断的条件基于的是同一个变量,只是根据变量值的不同而有不同的分支, 如果值比较多，如根据星期几进行判断

```java
switch(表达式 ){
case 值1:
代码1; break;
case 值2:
代码2; break;
…
case 值n:
代码n; break;
default: 代码n+1
}
```

根据表达式的值执行不同的分支,具体来说,根据表达式的值找匹配的case ,找到后执行后面的代码,**碰到break时结束**,如果没有找到匹配的值则执行default后的语句。表达式值的数据 类型只能是**byte、 short、int、 char、枚举和String**  。

需要注意的是：每条case语句后面都应该跟break语句,否则会继 续执行后面case 中的代码直到碰到break语句或switch结束。否则就会发生case穿透



### 1.4.2 实现原理（理解）

程序最终都是一条条的**指令**, CPU有一个**指令指示器**,指向下一条要 执行的指令, CPU根据指示器的指示加载指令并且执行。

有一些特殊的指令,称为**跳转指令**：修改指令指示器的值,**让CPU跳到一个指定的地方执行**。

跳转指令分为两种：

1. 条件跳转：检查某个条件,满足则进行跳转
2. 无条件跳转：直接进行跳转

以if else举例：会转换为这些跳转指令

```java
1 int a=10;
2 if(a%2==0)
3 {
4    System.out.println("偶数");
5 }
6 //其他代码
    
转换到的转移指令可能是:
1 int a=10;
2 条件跳转:如果a%2==0,跳转到第4行
3 无条件跳转:跳转到第7行
4 {
5    System.out.println("偶数");
6 }
7 //其他代码
```

在单一if的情况下可能不用无条件跳 转指令,但稍微复杂一些的情况都需要。 **if、if/else、if/else if/else、三元运算符**都会转换为条件跳转和无条件跳转



关于switch的跳转：如果分支比较少,可能会转换为跳转指令。如果分支比较多,使 用条件跳转会进行很多次的比较运算,效率比较低,可能会使用一种更为高效的方式,叫**跳转表**。



















































































































































































