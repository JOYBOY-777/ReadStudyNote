# 脑图

### java基础

java 基础之**继承**：https://www.processon.com/view/link/6173e2b71e08537415f8672b







### java集合

ArrayList:https://www.processon.com/view/link/61376e1ce401fd1fb6afe32f

LinkedList:https://www.processon.com/view/link/6139c33d1efad40d93a5e396

ArrayDeque:https://www.processon.com/view/link/61dd6b1e1efad4259c5bbfaf

HashMap:https://www.processon.com/view/link/61519138079129511c908cd3

TreeMap:https://www.processon.com/view/link/61dd6b551efad4259c5bc015

HashSet:https://www.processon.com/view/link/61dd6b84f346fb06cb913d91

LinkedHashMap:https://www.processon.com/view/link/61dd6ba01efad4259c5bc09a







### IO流

二进制文件和字节流：https://www.processon.com/view/link/616c10057d9c08665140b91f

java文件概述：https://www.processon.com/view/link/61dd6be80e3e74415778474f







### 并发

并发基础知识：https://www.processon.com/view/link/617ab42f1efad4489404d11b

并发包的基石：https://www.processon.com/view/link/618d1c811efad41bf2c26971







### 堆与优先队列

PriorityQueue:https://www.processon.com/view/link/61dd6cd1e401fd06a8c52580

堆与优先级队列：https://www.processon.com/view/link/6162e1567d9c0866512e589e





# 笔记

## 第一章 编程基础

### 1.1 数据类型和变量

在java中有一下四大种**数据类型**：

1. 整数类型：有4种整型byte/short/int/long,这四种对应的取值范围是不同的
2. 小数类型：有两种类型ﬂoat/double，有不同的取值范围和精度
3. 字符类型：char,表示单个字符
4. 真假类型：boolean，表示真假

**变量**：为了操作数据,需要把数据存放到内存中。所谓内存在程序看来就是一块有**地址编号的连续的空间**,数据放到内存中的某个位置后,为了方便地找到和操作这个数据,需要给这个位置起一个名字，这个名字就是变量。

比如 int a:内存中分配了一块空间,这块空间存放int数据类型, a指向这块内存空间所在的位置,通过对a操作即可操作**a指向的内存空间**,那么a = 5这个操作即可将a指向的内存空间的值改变为5，那么变量的含义就是：**变量就是给数据起名字,方便找不同的数据,它的值可以变,但含义不应变。**



### 1.2.1 赋值与基本类型

**赋值：**声明变量之后,就在内存分配了一块位置，赋值就是把这块位置的内容设为一个**确定的值**。

**基本类型**：

1.整数类型：整数类型有byte、 short、int和long,分别占1、 2、4、 8个字节，他们的取值范围如下

![](https://raw.githubusercontent.com/JOYBOY-777/ReadStudyNote/main/javaimg/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)

不过要注意的是在给long类型赋值的时候,**如果常量超过了int的表示范围**,要在后面加上L

比如：

``` java
long a = 3232343433L;
```



2.小数类型：小数类型有ﬂoat和double,占用的内存空间分别是4和8字节,有不同的取值范围和精度, double表示的范围更大,精度更高。他们的取值范围如下：

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/double.png?raw=true)

在给double赋值的时候就直接赋值就行

```java
double d = 333.33;
```

但是由于小数类型的话默认为double类型那么在赋值float的时候就需要在后面写上f

```java
float f = 333.33f;
```

也可以把小数直接赋值给float,double

```java
float f = 33;
double d = 3333333333333L;
```



3.真假类型：直接赋值就行了

```java
boolean b = true;
b = false;
```



4.字符类型：字符类型用于表示一个字符，可以是**中文字符**，也可以是**英文字符**，char占用两个字节，赋值的时候用''括起来

```java
char c = 'A';
char z = '马 ';
```



### 1.2.2 数组类型

在java中给数据赋值的形式有三种：

```java
1. int[] arr = {1,2,3};
2. int[] arr = new int[]{1,2,3};
3. int[] arr = new int[3];      arr[0]=1; arr[1]=2; arr[2]=3;
```

第三种赋值方式，如果没有给数组赋值那么也会有**默认值**。这个默认值跟数组的类型有关

注意：不能在给定初始值的同时给定长度,这样是不被允许的

```java
int[] arr = new int[3]{1,2,3}
```



数组类型和基本类型是有明显不同的：

1. 一个基本类型变量,内存中只会有一块对应的内存空间
2. 数组有两块内存空间：一块用于存储**数组内容本身**，另一块存储**内容的位置** 

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%88%AB.png?raw=true)

比如数组arr的内存地址是2000，这 个位置存储的值是**一个位置**3000 ，3000开始的位置存储的才是**实际的数据**1 , 2 , 3

为什么这样呢？例子：

```java
int[] arrA = {1,2,3};
int[] arrB = {4,5,6,7};
arrA = arrB;
```

如果arrA对应的内存空间是直接存储的数组内容,那么它将没有足够的空间去容纳arrB的所有元素。

arrA = arrB;其实是体现的如下过程

```java
arrA     {1,2,3}
      \
        \
arrB  -> {4,5,6,7}
```

所以数组变量赋值则会让变量指向一个不同的位置



### 1.3 基本运算

java中的基本类型数据的主要运算包括：

1. 算术运算：主要是日常的加减乘除
2. 比较运算：主要是日常的大小比较
3. 逻辑运算：针对布尔值进行运算



### 1.3.1 算数运算

算数运算包括：加、减、乘、除，符号为：\+ 、 - 、 * 、 /，以及取模运算符（求余）%，以及自增 (++ )和

自减 (-- )运算符

1.加、减、乘、除注意事项

```java
int a = 2147483647*2; //2147483647是int能表示的最大值   a的结果是2
```

运算时要注意结果的范围,**使用恰当的数据类型**,两个正数都可以用int表示,但**相乘的结果可能就会超出**,结果也会让人疑惑，我们应该使用long来接收a，但是但只改为 long也是不够的,因为运算还是**默认按照int类型进行**,需要将**至少一个**数据表示为long形式,即在后面加 L或l

```java
long a = 2147483647*2L;
```

整数想出的时候**不是四舍五入**，而是**直接舍去小数位**

```java
double d = 10/4;
```

如果要想让结果正确的话，也需要将其中之一的数变为小数

```java
a) double d = 10/4.0;
b) double d = 10/(double)4;
```



2.小数的计算结果也不算精确比如：

```java
float f = 0.1f*0.1f;
System.out.println(f); //实际的输出是0.010000001
```



3.自增自减 ++ --

自增/自减是对自己做加1或减1操作,但每个都有两种形式,一种是放在变量后,例如a++、 a-- ,另一 种是放在变量前,例如++a、 --a

这里需要注意：

1. 如果只是对自己操作,这两种形式也没什么差别
2.  当后面还有其他操作时，放在变量后  (a++ )是先**用原来的值**进行其他操作,然后**再对自己做修改**
3. 放在变量前 (++a )是先**对自己做修改**,再用**修改后的值**进行其他操作       可参考下表：

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/%E8%87%AA%E5%A2%9E%E6%93%8D%E4%BD%9C.png?raw=true)



### 1.3.2  比较运算

比较运算就是计算两个值之间的关系,结果是一个**布尔类型** (boolean)的值

比较操作符有大于(>)、大于等于 (>= )、小于(<)、小于等于 (<= )、等于 (== )、不等于 (!= )，一个=表示的是赋值的操作



### 1.3.3 逻辑运算

逻辑运算根据**数据的逻辑关系**,生成一个布尔值true或者false 

逻辑运算符包括：

1. 与 (&):**两个都为true**才是true ,只要有一个是false就是false
2. 或 (|):**只要有一个为true**就是true ,都是false才是false
3. 非(!):针对一个变量, true会变成false , false会变成true
4. 异或 (^):**两个相同为false,两个不相同为true**
5. 短路与 (&&):和&类似
6. 短路或 (||):与|类似

但是&和&&,以及|和||的区别要注意一下：

```java
boolean a = true;
int b = 0;
boolean flag = a | b++>0;
```

|的话就要前后都看，尽管a的值已经是true了，但是也要看一下b，此时b为1，|后面的式子也会进行运算，而||则不同，比如

```java
boolean flag = a || b++>0;
```

则b的值还是0,因为||会“**短路**”,即在看到||前面部分就可以判定结果的情况下,忽略||后面的运算



### 1.4 条件执行

流程控制中最基本的就是条件执行,也就是说,一些操作只能在某些条件满足的情况下才执行,在  一些条件下执行某种操作,在另外一些条件下执行另外的操作。

### 1.4.1 语法和陷阱

if语句：只在条件语句为真的情况下,才执行后面的代码,为假就不执行了。

```java
if(条件语句){
代码块
}
或者
if(条件语句) 代码 ;    
```

具体来说,条件语句必须为布尔值,可以是一个**直接的布尔变量**,也可以是**变量运算后的结果**。建议所有的if后面都加上括号



if else语句：满足的时候执行某种逻辑,而 不满足的时候执行另一种逻辑

```java
if(判断条件){
代码块1
}else{
代码块2
}
```



三元运算符：三元运算符会得到一个结果,判断条件为真的时候就返回表达式1的值,否则就返回表达式2的值

```java
判断条件  ? 表达式  1 :   表达式2
int max = x > y ? x : y;
```



if/else if/else:如果有多个判断条件,而且**需要根据这些判断条件的组合**执行某些操作,容易理解成else if其实不是

```java
if(条件1){
代码块1
}else if(条件2){
代码块2
} …
else if(条件n){
代码块n
}else{
代码块n+1
}
```

条件1满足则执行代码块1,不满足则检查条件2 , …… ,最后如果没有条件满足,且有else语句,则执行else里面的代码最后的else语句不是必需的,**没有就什么都不执行**。



switch case：针对于判断的条件基于的是同一个变量,只是根据变量值的不同而有不同的分支, 如果值比较多，如根据星期几进行判断

```java
switch(表达式 ){
case 值1:
代码1; break;
case 值2:
代码2; break;
…
case 值n:
代码n; break;
default: 代码n+1
}
```

根据表达式的值执行不同的分支,具体来说,根据表达式的值找匹配的case ,找到后执行后面的代码,**碰到break时结束**,如果没有找到匹配的值则执行default后的语句。表达式值的数据 类型只能是**byte、 short、int、 char、枚举和String**  。

需要注意的是：每条case语句后面都应该跟break语句,否则会继 续执行后面case 中的代码直到碰到break语句或switch结束。否则就会发生case穿透



### 1.4.2 实现原理（理解）

程序最终都是一条条的**指令**, CPU有一个**指令指示器**,指向下一条要 执行的指令, CPU根据指示器的指示加载指令并且执行。

有一些特殊的指令,称为**跳转指令**：修改指令指示器的值,**让CPU跳到一个指定的地方执行**。

跳转指令分为两种：

1. 条件跳转：检查某个条件,满足则进行跳转
2. 无条件跳转：直接进行跳转

以if else举例：会转换为这些跳转指令

```java
1 int a=10;
2 if(a%2==0)
3 {
4    System.out.println("偶数");
5 }
6 //其他代码
    
转换到的转移指令可能是:
1 int a=10;
2 条件跳转:如果a%2==0,跳转到第4行
3 无条件跳转:跳转到第7行
4 {
5    System.out.println("偶数");
6 }
7 //其他代码
```

在单一if的情况下可能不用无条件跳 转指令,但稍微复杂一些的情况都需要。 **if、if/else、if/else if/else、三元运算符**都会转换为条件跳转和无条件跳转



关于switch的跳转：如果分支比较少,可能会转换为跳转指令。如果分支比较多,使 用条件跳转会进行很多次的比较运算,效率比较低,可能会使用一种更为高效的方式,叫**跳转表**。

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/%E8%B7%B3%E8%BD%AC%E8%A1%A8.png?raw=true)

关于switch为什么不能用long作为条件式类型？

因为：**跳转表值的存储空间一般为32位,容纳不下long**



### 1.5 循环

所谓循环,就是多次重复执行某些类似的操作,这个操作一般不是完全一样的操作,而是类似的操作。



### 1.5.1 循环的四种形式

在Java中,循环有4种形式,分别是**while、 do/while、for和foreach**（增强for循环）

1.while

语法：

```java
while(条件语句){
代码块
}
或者
while(条件语句) 代码块    
```

只要条件语句为真,就一直 执行后面的代码,为假就停止不做了



2.do/while

语法：

```java
do{
代码块;
}while(条件语句)
```

不管条件语句是什么,代码块都会至少执行一次,先执行代码块,然后再判断条件语句,如果成立,则继续循环,否则退出循环。也就是说,不管条件语句是什么,**代码块都会至少执行一次**。



3.for

语法:

```java
for(初始化语句 ; 循环条件; 步进操作){
循环体
}
```

除了循环条件必须返回一个boolean类型外,**其他语句没有什么要求**,但通常情况下第一条语句用于初始化,尤其是循环的索引变量,第三条语句修改循环 变量,**一般是步进,即递增或递减索引变量**,循环体是在循环中执行的语句

for循环的执行流程：

1. 执行初始化指令
2. 检查循环条件是否为true ,如果为false,则跳转到第6步
3. 循环条件为真,执行循环体
4. 执行步进操作
5. 步进操作执行完后,跳转到第2步,即继续检查循环条件
6. for循环后面的语句



在for循环中每条语句可以是空的

```java
for(;;){}
```

这是个死循环,一直在空转,和while (true) {}的效果是一样的



4.foreach

语法：

```java
int[] arr = {1,2,3,4};
for(int element : arr){
System.out.println(element);
}
```

增强for，冒号前面是循环中的每个元素,包括数据类型和变量名   称,冒号后面是要遍历的数组或集合，每次循环element都会自动更新。对于不需要使用索 引变量,只是简单遍历的情况, foreach语法上更为简洁



### 1.5.2 循环控制

在循环的时候,会以循环条件作为是否结束的依据,但有时可能会需要根据别的条件提前结束循环 或跳过一些代码，这时候就可以使用break或continue

1.break：break用于提前结束循环

```java
int[] arr = … ; //在该数组中查找元素
int toSearch = 100; //要查找的元素
int i = 0;
for(; i<arr.length; i++){
if(arr[i]==toSearch){
      break; //直接跳出循环
    }
}
if(i!=arr.length){
System.out.println("found");
}else{
System.out.println("not found");
}
```



2.continue：跳过这一轮循环,continue语句会跳过循环体中剩下的代码,然后**执行步进操作**

```java
int[] arr = …     //在该数组中查找元素
int toSearch = 2;         //要查找的元素
int count = 0;
for(int i=0; i<arr.length; i++){
if(arr[i]!=toSearch){
    continue;
 }
count++;
}
System.out.println("found count "+count);
```

如果值不等于toSearch,则跳过剩下的循环代码,**执行i++**



### 1.5.3 实现原理

循环内部也是靠条件转移和无条件转移指令实现的

```java
int[] arr = {1,2,3,4};
for(int i=0; i<arr.length; i++){
System.out.println(arr[i]);
}

对应的跳转过程可能为
1 int[] arr = {1,2,3,4};
2 int i=0;
3 条件跳转:如果i>=arr.length,跳转到第7行
4 System.out.println(arr[i]);
5 i++
6 无条件跳转,跳转到第3行
7 其他代码    
    
```

虽然循环看起来只是重复执行一些类似的操作而已,但它其实是**计算机程序解决问题的一种基本思维方式**



### 1.6 函数的用法

计算机程序使用函数这个概念来解决这个问题,即使用函数来减少重复代码和分解复杂操作

### 1.6.1 基本概念

语法：

```java
修饰符  返回值类型    函数名字(参数类型  参数名字 , …) {
              操作
         return 返回值;
}
```

主要包含：

1. 函数名字:名字是不可或缺的,表示函数的功能
2. 参数:参数有0个到多个,每个参数由参数的数据类型和参数名字组成
3. 操作:函数的具体操作代码
4. 返回值:函数可以没有返回值,如果没有返回值则类型写成void,如果有则在函数代码中必须使用return语句返回一个值,**这个值的类型需要和声明的返回值类型一致**
5. 修饰符: Java中函数有很多修饰符,分别表示不同的目的



### 1.6.2 进一步理解函数

1.参数传递

(1)数组：在函数内修改数组中的元素会修改调用者中的数组内容，因为数组有两块存储空间

(2)可变长度的参数

```java
public static int max(int min, int ... a){
      int max = min;
      for(int i=0;i<a.length;i++){
        if(max<a[i]){
         max = a[i];
     }
}
    return max;
}
public static void main(String[] args) {
System.out.println(max(0));
System.out.println(max(0,2));
System.out.println(max(0,2,4));
System.out.println(max(0,2,4,5));
}
```

可变长度参数的语法 是在数据类型后面加三个点“...”,在函数内,可变长度参数可以看作是**数组**。可变长度参数必须是**参数列表中的最后一个**,一个函数也只能有**一个**可变长度的参数



2.理解返回

1. 函数返回值类型为void时, return不是必需的,在没有return的情 况下,会执行到函数结尾自动返回
2.  return用于显式结束函数执行,返回调用方
3. return可以用于函数内的任意地方,可以在函数结尾,也可以在中间,可以在if语句内,可以在for循 环内,用于提前结束函数执行,返回调用方
4. 函数返回值类型为void也可以使用return,即“return; ”,不用带值,含义是返回调用方,只是没有返 回值而已。
5. 函数的返回值最多只能有一个



3.重复的命名

1. 函数的名字可以重复
2. 同一个类里,函数可以重名,但是参数不能完全一样
3. 同一个类中函数名相同但参数不同的现象,一般称为**函数重载**



4.调用的匹配过程

1. 参数传递实际上是给**参数赋值**
2. 调用者传递的数据需要与函数声明的参数类型是匹配的
3. 在只有一个函数的情况下,即没有重载,**只要可以进行类型转换,就会调用该函数**,在**有函数重载**的情况下,会调用**最匹配的函数**

```java
char a = 'a';
char b = 'b';
System.out.println(Math.max(a,b));
```

Java会自动将char转换为int,然后调用Math.max (int a , int b),如果Math中没有定义针对int类型的max函数呢?调用也会成功,会调用long类型的max函数。如果  long也没有呢?会调用ﬂoat型的max函数。如果ﬂoat也没有,会调用double型的。 Java编译器会自动寻找**最匹配**的。



5.递归函数

阶乘示例：

```java
public static long factorial(int n){
       if(n==0){
              return 1;
       }else{
             return n*factorial(n-1);
      }
}
```

但是在调用System.out.println(factorial(100000));的时候系统会抛出异常，java.lang.StackOverﬂowError，表示栈溢出错误

函数是计算机程序的一种重要结构, **通过函数来减少重复代码、分解复杂操作是计算机程序的一种重要思维方式。**



### 1.7 函数调用的基本原理

函数调用的实现机制跟栈有关系

### 1.7.1  栈的概念

调用函数过程中存在的问题i:

1. 参数如何传递
2. 函数如何知道返回到什么地方
3. 函数结果如何传给调用方

答案是：使用内存来存放这些数据（栈）

1. 栈是一块内存,但它的使用有特别的约定,一般是先进后出,类似于一个桶,往栈里放数据称为入  栈,最下面的称为栈底,最上面的称为栈顶,从栈顶拿出数据通常称为出栈。
2. 栈一般是从高位地址向低位 地址扩展,换句话说,栈底的内存地址是最高的,栈顶的是最低的



函数的返回值存放在一个专门的返回值存储器中，main函数的相关数据放在栈的最下面,每调用一次函数,都会将**相关函数的数据入栈**,**调用结束会出栈**



### 1.7.2 函数执行的基本原理

```java
1 public class Sum { 2
3     public static int sum(int a, int b) {
4            int c = a + b;
5            return c;
6     }
7
8     public static void main(String[] args) {
9          int d = Sum.sum(1, 2);
10        System.out.println(d);
11     }
12 }
```

当程序在**main**函数调用Sum.sum之前,栈的情况,栈中主要存放了两个变量args和d

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/sum%E4%B9%8B%E5%89%8D.png?raw=true)

在程序执行到Sum.sum的函数内部,准备返回之前,即第5行,栈的情况:

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8.png?raw=true)

以上的过程可以简单的描述为

1. main函数调用Sum.sum之前，将main方法的参数arg和d入栈
2. 在main函数调用Sum.sum时，首先将参数1和2入栈
3. 将**调用函数结束后**要执行的**指令地址**，简单来说就是调用函数结束后，要跳转到哪个地址上去
4. 接着跳转到sum函数，为局部变量c分配一个空间
5. 在返回之前,返回值保存到了专门的返回值存储器中
6. 在调用return后,程序会跳转到栈中保存的返回地址（主程序具体的哪一行上）
7. sum函数相关的 数据会出栈

函数中的参数和函数内定义的变量,都分配在栈中,这些变量  只有在**函数被调用的时候才分配**,而且**在调用结束后就被释放了**。但这个说法主要针对**基本数据类型**



### 1.7.3  数组和对象的内存分配

数组和对象类型，它们都有两块内存,一块存放实际的内容,一块存放实际内容的地址，实际的内容（对象，或者数组的真实值等）空间一般不是分配在栈上的,而是分配在**堆中**，但存放地址的空间（对象引用，数组引用）是分配在**栈上**的

```java
public class ArrayMax {
    public static int max(int min, int[] arr) {
       int max = min;
       for(int a : arr){
          if(a>max){
            max = a;
      }
}
      return max;
}
public static void main(String[] args) {
    int[] arr = new int[]{2,3,4};
     int ret = max(0, arr);
     System.out.println(ret);
}

```

程序执行到max函数的return语句之前的时候,内存中**栈和堆**的情况

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/%E6%95%B0%E7%BB%84%E6%A0%88%E5%92%8C%E5%A0%86.png?raw=true)

对于数组arr ,在栈中存放的是实际内容的地址0x1000,存放地址的栈空间会随着入栈分配出栈释,但存放实际内容的堆空间不受影响



### 1.7.4 递归调用的原理

```java
public static int factorial(int n){
       if(n==0){
          return 1;
       }else{
          return n*factorial(n-1);
       }
}
public static void main(String[] args) {
      int ret = factorial(4);
      System.out.println(ret);
}
```

在factorial第一次被调用的时候, n是4,在执行到n*factorial (n-1),即4*factorial  (3)之前的时候, 栈的情况，这时只有基本的几个变量入栈

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/%E6%A0%881.4.png?raw=true)





这时的返回值存储器是没有值的,在调用factorial (3)后,栈的情况，

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/%E6%A0%881.5.png?raw=true)

栈的深度增加了,返回值存储器依然为空,就这样,每递归调用一次,栈的深度就增加一层,每次  调用都会分配对应的参数和局部变量,也都会保存调用的返回地址，这里的**factorial(4)的下一条指令地址记录的是n*f(3)执行完要跳转到f(4)的什么位置的地址** 





在调用到n等于0的时候,栈的情况：

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/1.6%E6%A0%88.png?raw=true)

这个时候,终于有返回值了,我们将factorial简写为f。f (0)的返回值为1 ; f (0)返回到f (1), f (1)执行1乘f (0),结果也是1;然后返回到f (2), f (2)执行2乘f (1),结果是2;接着返回到  f (3), f (3)执行3乘f (2),结果是6;然后返回到f (4)，执行4乘f (3),然后跳转到main函数相应的代码位置，在进行后续的出栈操作

**之前的情况是先执行函数，在记录要跳转的地方，后来出栈，就变成了先跳转在执行**，以上就是递归函数的执行过程,函数代码虽然只有一份,但在执行的过程中,每调用一次,就会有 一次入栈,生成一份不同的参数、局部变量和返回地址



函数调用主要是通过栈来存储相关的数据,系统就函数调用者和 函数如何使用栈做了约定,返回值可以简单认为是通过一个专门的返回值存储器存储的，另 外,栈的空间不是无限的,一般正常调用都是没有问题的,但如果栈空间过深,系统就会抛出错误   java.lang.StackOverﬂowError ,即栈溢出。



## 第二章 理解数据背后的二进制

### 2.1  整数的二进制表示与位运算

十进制：123表示1× (10^2) +2× (10^1) +3× (10^0) 注意：最低位从10的0次方开始计算

### 2.1.1 正整数的二进制表示

跟十进制相比，二进制就是把10换成2 比如二进制111 变为十进制就是 1x(2^2)+1x(2^1)+1x(2^0) = 4+2+1 = 7

可参照下表：

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/%E4%BA%8C%E8%BF%9B%E5%88%B6.png?raw=true)

### 2.1.2  负整数的二进制表示

十进制：十进制的负数表示就是在前面加一个负数符号- ,例如-123

二进制：二进制使用最高位表示符号位,用**1表示负数**,用**0表示正数**，整数有四种类型：byte、 short、int、long,分别占1、 2、4、 8个字节,即分别占8、 16、 32、 64位，每种类型的符号位都是**其最左边的一位**

但是负数表示**不是简单地将最高位变为1** ：比如

1. byte a=-1,如果只是将最高位变为1,二进制应该是10000001,但实际上,它应该是11111111
2. byte a=-127,如果只是将最高位变为1,二进制应该是11111111,但实际上,它却应该是 10000001

这时候另一个概念**补码表示法**就出来了，以上的叫做**源码表示法**，这两种关系为：补码表示就是在**原码表示**的基础上**取反**然后加**1 **比如：

1. -1 : 1的原码表示是00000001,取反是11111110,然后再加1,就是11111111
2. -2 : 2的原码表示是00000010,取反是11111101,然后再加1,就是11111110
3. -127 : 127的原码表示是01111111,取反是10000000,然后再加1,就是10000001

比如一个负数的二进制表示想知道他的十进制位表示：10010010，取反,变为01101101，加1结果为01101110，它的十进制值为110，那么这个数就是-110，计算机只能做加法,而补码的一个良好特性就是,对**负数的补码表示做补码运算**就可以得到其**对应正数的原码**

对于**byte**类型,正数最大表示是01111111,即127,负数最小表示(绝对值最大)是10000000 , 即-128,表示范围就是**-128 ~127** 



为什么要采取补码呢？

只有这种形式,计算机才能实现正确的加减法，计算机其实只能做加法, 1-1其实是1+ (-1)，如果用源码计算结果是不对的：

```java
1  -> 00000001
-1 -> 10000001
+ ------------------
-2 -> 10000010
```

所以减去一个数等于加上这个数的补码：

```java
1  -> 00000001
-1 -> 11111111
+ ------------------
0  -> 00000000
```



为什么整数的运算可能出现负数呢？

因为：当计算结果超出表示 范围的时候,最高位往往是1,然后就会被看作负数。比如, 127+1

```java
127   -> 01111111
1     -> 00000001
+ ------------------
-128  -> 10000000
```



### 2.1.3 十六进制

二进制写起来太长,为了简化写法,可以将**4个二进制位简化为一个0~15的数**, **10~15用字符A~F表示**,这种表示方法称为十六进制

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6.png?raw=true)

比如十进制的123：十六进制直接写常量数字,在数字前面加0x即可，123用16进制表示为0x7B，即123=7×16+11

Java中,可以方便地使用**Integer和Long**的方法查看**整数的二进制和十六进制**表示

```java
System.out.println(Integer.toBinaryString(a)); //二进制
System.out.println(Integer.toHexString(a)); //十六进制
System.out.println(Long.toBinaryString(a)); //二进制
System.out.println(Long.toHexString(a)); //十六进制
```



### 2.1.4 位运算

位运算有**移位运算**和**逻辑运算**

**移位运算**：

1. 左移：操作符为<< ,向左移动,右边的低位补0,高位的就舍弃掉了,将二进制看作整数,左移1 位就相当于乘以2。
2. 无符号右移：操作符为>>> ,向右移动,右边的舍弃掉,左边补0，注意：无论是正数还是负数，**右移的时候高位都统一补0**，没有符号限制
3. 有符号右移：操作符为>> ,向右移动,右边的舍弃掉,左边补什么取决于原来**最高位**是什么,原 来是1就补1,原来是0就补0,将二进制看作整数,右移1位相当于除以2

```java
int a = 4; //100
a = a >> 2; //001,等于1
a = a << 3 //1000,变为8
```

**逻辑运算**:

1. 按位与&:两位都为1才为1
2. 按位或|:只要有一位为1,就为1
3. 按位取反~ : 1变为0 , 0变为1
4. 按位异或^:相异为真,相同为假



### 2.2 小数的二进制表示

之前会发生不精确的例子：结果是0.01但是实际上是0.010000001

```java
float f = 0.1f*0.1f;
System.out.println(f);
```



### 2.2.1 小数计算为什么会出错

1. 实际上,不是运算本身会出错,而是计算机根本就不能精确地表示很多数,比如0.1这个数
2. 计算机 是用一种二进制格式存储小数的,这个二进制格式**不能精确表示0.1**,它只能表示一个**非常接近0.1但又不 等于0.1的一个数**

在十进制表示12.345的时候，**十进制**也只能表示那些可以表述为**10的多少次方和的数**，为1×10+2×1+3×0.1+4×0.01+5×0.001，但是表示1/3的话就不能用十进制表示，十进制表示是0.333,但无论后面 保留多少位小数,都是不精确的

二进制是类似的,但**二进制只能表示那些可以表述为2的多少次方和的数**比如：

![](https://github.com/JOYBOY-777/ReadStudyNote/blob/main/javaimg/2%E7%9A%84%E6%AC%A1%E6%96%B9%E6%95%B0.png?raw=true)

可以精确表示为**2的某次方之和的数**可以精确表示,其他数则不能精确表示，在在Java中BigDecimal ,运算更准确



### 2.2.2  二进制表示

“小数”是在数学中用 的词,在计算机中,我们一般说的是**“浮点数”** 。ﬂoat和double被称为浮点数据类型,小数运算被称为浮点运算

如果想查看浮点数的具体二进制形式,在Java中,可以使用如下代码

```java
Integer.toBinaryString(Float.floatToIntBits(value))
Long.toBinaryString(Double.doubleToLongBits(value));
```



### 2.3 char的真正含义

char用于表示一个字符,这个字符可以是中文字符, 也可以是英文字符，赋值时把常量字符用单引号括起来

1. char本质上是一个固定占用**两个字节**的**无符号正整数**
2. 这个正整数对应于Unicode编号,用于表示那个Unicode编号对应的字符
3. 注意：char只能表示Unicode编号在**65536以内的字符**,而不能表示超出范围的字符，因为Unicode编号范围在**65536以内**的占**两个**字节
4. char本质上是一个整数,所以可以进行整数能做的一些运算
5. 在进行运算时会被看作**int**,但由于 char占两个字节,运算结果不能直接赋值给char类型,需要进行强制类型转换



## 第三章 类的基础

 





































































































































